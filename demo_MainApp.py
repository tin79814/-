#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Dec 28 10:04:34 2019

@author: npchen
"""

# Import PyQt Widgets for PyQt5 version
from PyQt5.QtWidgets import QApplication, QMainWindow 

# Import pyqtSlot to connect sliders and DoubleSpinBox signals
from PyQt5.QtCore import pyqtSlot

# Import Ui_MainWindow class from UiMainApp.py generated by uic module
from UiMainApp import Ui_MainWindow



# 這裏 import 你以前的程式作業會用到的模組 (turtle, matplotlib 除外)
import math 
import mplturtle


# 這是用在隱藏座標軸的功能
import matplotlib.ticker as ticker

###################################
# 這裏放你的程式定義的函數
#def d2r(deg):
#    ...

            

class MainApp(QMainWindow, Ui_MainWindow):
    '''
    MainApp class inherits from QMainWindow and from Ui_MainWindow class in
    UiMainApp module
    '''
    
    def __init__(self):
        '''
        constructor or initializer
        '''
        QMainWindow.__init__(self)
        
        # It is imperative to call
        # self.setupUi(self) for the interface to initialize.
        
        # This is defined in Ui_MainWindow  automatically
        # It sets up layout and widgets that are defined
        self.setupUi(self)
        self.fig1()
        
    def fig1(self):
        # the code of simulation

        #################################
        '''
        這裏是你的程式需要變動的參數 (例如，波長、折射率、透鏡曲率半徑……)
        用與講義最後範例一樣的方式取得數值
        n = self.slider_n.value()
        
        
        借用講義最後範例設定的 widget 界面
        
        '''
        y0 = self.slider_y0.value() 
        r = self.slider_r.value()
        n2 = self.slider_n2.value()/10 #透鏡折射率       
        n1 = self.slider_n1.value()/10#環境折射率
        theta0 = self.slider_theta0.value() 
        
        ####### 
        '''
        這裏是其他參數 (不需要用滑桿取得，內定值) 的定義區
        '''

        
        ########
        '''
        設定 mpl widget
        '''

        mpl = self.mplwidget.canvas
        mpl.ax.clear()
        

        
        
        ########################## begin calculation
        '''
        這裏放你的海龜繪圖程式碼

        # 海龜繪圖最後要有這個 t.show(mpl.ax)
         '''


        t = mplturtle.MplTurtle()

        def d2r(deg):
            '''
            角度轉徑度回傳
            '''
            """ degree to radian conversion """
            return deg * math.pi / 180
        
        def r2d(rad):    
            '''
            徑度轉角度回傳
            '''
            return rad * 180/math.pi
        
        def	dashed_line(a_turtle,	distance,	segment=10):
            '''
            以海龜 a_turtle 目前的位置出發，目前的方位為方向，畫出總長是 d 的虛線
            畫完後，海龜在終點位置
            '''	
            accumulation	=	0	
            pen_down	=	True	
            while	accumulation	<	int(distance/segment)	*	segment	:	
                if	pen_down:
                    a_turtle.pendown()	
                else:
                    a_turtle.penup()	
                a_turtle.forward(segment)	
        									
                accumulation	+=	segment	
        									
         #	flip	the	value:	True	becomes	False;	False	becomes	True	
                pen_down	=	not	pen_down	
        #	there's	remainder;	complete	it	
            if	accumulation	<	distance:	
                if	pen_down:	
                    a_turtle.pendown()	
                else:    
                    a_turtle.penup()	
            									
                a_turtle.forward(distance	-	accumulation)	
            #	set	to	pendown	before	return		
            a_turtle.pendown()
        
        def curve(t,r,A):
            '''
            必須預設 海龜的出發點 (圓心) 以及 方位朝光軸 (從起始到終止、從左到右)
            執行之後，海龜回到原出發點，以及原方位
            pendown
            '''
            if r < 0:
                t.left(180)
                t.penup()
                # t.forward(r)
                #前進到弧
                t.left(180-A/2)
                t.forward(abs(r))
                t.left(90) 
                t.pendown()   
                #畫弧
                t.circle(abs(r),A)   
                #回到圓心
                t.penup()
                t.left(90)
                t.forward(abs(r))
                t.right(A/2)
            
            else:
        
                t.penup()
                # t.forward(r)
                #前進到弧
                t.left(180-A/2)
                t.forward(abs(r))
                t.left(90)       
                t.pendown()        
                #畫弧
                t.circle(abs(r),A)       
                #回到圓心
                t.penup()
                t.left(90)
                t.forward(abs(r))
                t.right(A/2)
        
        def quad(a,b,c):
            '''
            解一元二次方程式
            a x^2 + b x + c = 0
            回傳解 (x1, x2)
            如果沒有實根，則回傳 (None, None)
            '''
            delta = b*b - 4*a*c 
            if delta >= 0 :
                x1 = (-b - (delta)**0.5)/(2*a)
                x2 = (-b + (delta)**0.5)/(2*a)
            else :
                x1 = None
                x2 = None
            return(x1,x2)    
            
        def get_intersect(x0,y0,r0, xc,yc,r,A):
        
            '''
            回傳直線與圓弧的交會點 (xq, yq)
            直線是通過 (x0, y0) 點，沿著 r0 向量
            圓弧是以 (xc, yc) 為圓心，半徑為 r,弧度為 A 度，的凸面
            '''
            m0 = r0[1]/r0[0]
            a = (1+m0*m0)
            b = -2*xc - 2*x0*m0*m0 + 2*m0*y0 - 2*m0*yc 
            c = yc*yc - r*r + xc*xc +m0*m0*x0*x0 -2*m0*y0*x0 + y0*y0 + 2*m0*yc*x0 - 2*yc*y0
            x1, x2= quad(a,b,c)
            
            if r > 0:
                xq = x1
            else:
                xq = x2 
                
            yq = m0 * (xq-x0) + y0
            return (xq,yq)
        ##########################
        
        def v2dir(vec):
        
            '''
            輸入 二維向量 (有兩個分量 vec[0] 與 vec[1])
            回傳此向量指向的方位角 (度)
            '''
            theta = r2d(math.atan(vec[1]/vec[0]))
            
            if vec[0] < 0:
                 theta = theta + 180 
            return(theta)        
            
        ##########################
        
        def get_length(vec):
        
            '''
            回傳向量 vec 的長度
            '''
            aa = vec[0]*vec[0]
            bb = vec[1]*vec[1]
            return(abs((aa+bb)**0.5))
        
        
        ##########################
        
        def get_rn(xq,yq,xc,yc):
        
            '''
            回傳向量 (單位向量)， 入射點在 (xq,yq) 的法向量 (從圓心射出)
            '''
            vx = xq - xc 
            vy = yq - yc
            v =get_length((vx,vy))
            r_n = (vx/v,vy/v)
            if r_n[0] > 0:
                r_n = (-r_n[0],-r_n[1])
            return(r_n)
        
        ##########################
        #畫法線
        def normal(t,xq,yq,r_n, d = 200):
        
            '''
            畫法線, 長度是 d 中點在 (xq,yq)
            法向量是 rn, 用虛線
            畫完後回歸原來的位置與方位
            '''
            old_heading = t.heading()        
            t.penup()
            t.goto(xq,yq)
            theta = v2dir(r_n)
        
            t.setheading(theta)
            dashed_line(t, d/2)
            t.penup()
            t.goto(xq,yq)   
            t.setheading(theta+180)
            t.pendown()
            dashed_line(t, d/2)
            
            t.setheading(old_heading)
        
        ##########################
        
        def inner_product(vec1, vec2):
        
            '''
            回傳兩個向量的內積
            '''
            return (vec1[0]*vec2[0] + vec1[1]*vec2[1])
        
        ##########################    
        
        def get_incident_angle(r0,r_n):
        
            '''
            入射線沿著 r0 向量
            法線沿著 rn 法向量 (遠離圓心)
            r0 與 rn 之間的夾角用內積反推，cos(theta) = (r0 . rn) / (|r0|  |rn|)
            Theta 角如果大於90度則取補角，回傳 (度)
            '''
            # theta1 =r2d(math.acos(((r0[0] * r_n[0])+(r0[1]*r_n[1])) / ((r0[0]*r0[0]+r0[1]*r0[1])**0.5 * (r_n[0]*r_n[0]+r_n[1]*r_n[1])**0.5)))
            a = inner_product(r0, r_n) / (get_length(r0)*get_length(r_n))
           
            print(round(a,2))
            theta1 = r2d(math.acos(round(a,2)))
        
            if theta1 > 90 :
                theta1 = 180 - theta1   
            return(theta1)
        ##########################
        
        def get_critical_angle(n1, n2):
        
            '''
            只有 n1 > n2 的情況才計算臨界角, 回傳 (度)
            否則，回傳 None
            '''    
            if n1 > n2 :
                theta = r2d(math.asin(n2/n1))
                return(theta)
            else :
                return(None)
        
        ##########################
        
        def get_refraction_angle(theta1, n1, n2):
            '''
            用 Snell’s Law 計算折射角 theta2, 回傳
            如果有內部全反射發生，則回傳 None
            '''
            
            critical_theta = get_critical_angle(n1, n2)
            
            if critical_theta != None and theta1 > critical_theta :     
                theta2 = None       
            else:
                theta2 = r2d(math.asin(n1/n2*math.sin(d2r(theta1))))
            return(theta2)
        ##########################
        def get_sign(vec1,vec2):
            z = vec1[0] * vec2[1] - vec1[1] * vec2[0]	
            
            if z > 0:
                result=1
            elif z < 0:
                result=-1
            else:
                result = None	#表示異常結果
            return result
        
        def draw_a_ray(t,x0,y0,theta0,pencolor):
            r0 = (math.cos(d2r(theta0)),math.sin(d2r(theta0)))
            # r0 = (1,math.tan(d2r(theta0)))
            
            xq, yq= get_intersect(x0,y0,r0, xc,yc,r,A)
            
            t.penup()
            t.pencolor("black")
            t.goto(x0,y0)#發射點
            t.dot(5)
            t.setheading(theta0)#入射角
            t.pendown()
            
            #驗證，與鏡子的交點
            # t.forward(500)
            # t.penup()
            t.pencolor('orange')
            t.goto(xq,yq)#入射線與弧的焦點
            t.pencolor("black")
            t.dot(5)    
            t.pencolor('orange')
            old_x, old_y = t.position()
            old_heading = t.heading()
        #    dashed_line(t,400,segment=10) #入射點的延伸線
           
            
            
            r_n = get_rn(xq,yq,xc,yc)    
            t.pencolor("blue")
            normal(t,old_x,old_y,r_n,200)#畫法線   
            t.pencolor(pencolor)
            t.penup()
            t.goto(old_x,old_y)
            t.setheading(old_heading)
            t.pendown()
            
            theta1 = get_incident_angle(r0,r_n)  
            theta2 = get_refraction_angle(theta1, n1, n2)    
        
            sign = get_sign(r0, r_n)
            
            if theta2 != None and sign != None:
                #有折射
                if sign > 0:
                    delta = theta2 - theta1
                else:
                    delta = theta1 - theta2
            elif sign == None:
                delta=0
            else:
                #超過臨界角，只有全反射，沒有折射
                if sign > 0:
                    delta = 180 - 2*theta1
                else:
                    delta = 2*theta1 - 180
            #delta = theta2 - theta1#法線至折射角的角度
            print(theta1,theta2,delta)#檢查角度
            t.left(delta)
            t.forward(500)#折射線   
        #一入射點重複三次
        def draw_three_ray(r):
    
            if r > 0:#凸面介面
                x0 = -r-100   #入射點
            else:#凹面介面
                x0 = 0#入射點

            draw_a_ray(t,x0,y0,theta0,'green')  
        
        
        A = 60 
        #走到圓心&畫水平線
        t.forward(300)
        t.home()
        t.right(180)
        t.forward(300)
        t.home()
        t.dot(10) 
        
        curve(t,r,A)    
        

        #x0 = -300
        #y0 = 50
        xc = 0
        yc = 0
        
        draw_three_ray(r)
        

        
        

         
            
        t.show(mpl.ax)
        ##############################
        
        '''
        這裏是對於畫框的設定
        這裏示範把左、上、右框「拿掉」，只留下框
        '''
        mpl.ax.spines['right'].set_color('none')
        mpl.ax.spines['left'].set_color('none')
        mpl.ax.spines['top'].set_color('none')

        # 隱藏 y 軸刻度
        mpl.ax.yaxis.set_major_locator(ticker.NullLocator())
        
        # 設定 x 軸的刻度在下框
        mpl.ax.xaxis.set_ticks_position('bottom')
        
        # 設定橫向繪圖區域座標
        mpl.ax.set_xlim(-350, 500)
        
        # 設定縱向繪圖區域座標
        mpl.ax.set_ylim(-350, 500)
        
        #############################
        '''
        
        這個 fig1() 的最後要有 mpl.draw()
        '''
        mpl.draw()
        
        ##############################

    ############################
    '''
    設定 widget 彼此的連結，並設定改變 widget 時會重新繪圖 fig1()
    '''
        
    # DoubleSpinBox signals--- associate them to their corresponding sliders
    @pyqtSlot("double")
    def on_SpinBox_theta0_valueChanged(self, value):
        self.slider_theta0.setValue(value)
        
    @pyqtSlot("double")
    def on_SpinBox_y0_valueChanged(self, value):
        self.slider_y0.setValue(value)
        
    @pyqtSlot("double")
    def on_SpinBox_n2_valueChanged(self, value):
        self.slider_n2.setValue(value)
        
    @pyqtSlot("double")
    def on_SpinBox_r_valueChanged(self, value):
        self.slider_r.setValue(value)
        
    @pyqtSlot("double")
    def on_SpinBox_n1_valueChanged(self, value):
        self.slider_n1.setValue(value)

    
    # slider signals--- associate them to their corresponding SpinBoxes
    # also refresh the figure using new values
    @pyqtSlot("int")
    def on_slider_theta0_valueChanged(self, value):
        self.SpinBox_theta0.setValue(value)
        self.fig1()
        
    @pyqtSlot("int")
    def on_slider_y0_valueChanged(self, value):
        self.SpinBox_y0.setValue(value)
        self.fig1()
    
    @pyqtSlot("int")
    def on_slider_n2_valueChanged(self, value):
        self.SpinBox_n2.setValue(value)
        self.fig1()

    @pyqtSlot("int")
    def on_slider_r_valueChanged(self, value):
        self.SpinBox_r.setValue(value)
        self.fig1()
        
    @pyqtSlot("int")
    def on_slider_n1_valueChanged(self, value):
        self.SpinBox_n1.setValue(value)
        self.fig1()
#################################3
        
if __name__ == "__main__":
    import sys
    app = QApplication(sys.argv)
    MyApplication = MainApp()
    MyApplication.show()  # show the form (main window)
    sys.exit( app.exec_() )